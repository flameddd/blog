# 2023-04-30：筆記 samcurry 的 Filling in the Blanks: Exploiting Null Byte Buffer Overflow for a $40,000 Bounty
## samcurry (samwcyo), November 1, 2019
### https://samcurry.net/filling-in-the-blanks-exploiting-null-byte-buffer-overflow-for-a-40000-bounty/


----------------

據我知道，samwcyo 應該是白帽 hacker 界的超有名名人。之前讀了他跟朋友嘗試 hack apple 3 個月的 blog (拿到 28 萬美金獎金)，很厲害，所以我有興趣再讀讀他其他文章  

這種 bug 稱為: `null byte buffer overflow`

----------------

## 背景
我在舊金山。跟朋友幾個人第二天要去拉斯維加斯參加 DEFCON 之前，我們花了一天時間進行 hack 攻擊。

----------------

## 發現問題
最初我 pulled up application 時，我有一個想法
- 即通過使用些字符串操作技巧，將受害者的帳戶重新註冊到平台上
- 主要的想法是讓帳戶的用戶名是 `“victim”` 加上一個將被刪除的字符
  - （例如 `null byte`, `CRLF characters`, `spaces`, `weird Unicode` 等等）。

這是基於這樣的想法：
- 在註冊過程中，application 將把這個字符串傳遞給多個 function，並可能沿途刪除某些字符

What I was attempting, if successful, would look something like this  

我所嘗試的，如果成功的話，看起來會是這樣的:  
![](https://samcurry.net/wp-content/uploads/2019/11/Untitled-Diagram-2.png)  

我在測試註冊功能時試圖做的事情，如果成功了:
- 那 `attacker` 就會以 `“victim”` 這個用戶名登錄
- 雖然這在測試過程中沒有成功，但我認為這對理解我是如何處理這個 application 很有用。

我試圖用下面的字符來註冊一個帳戶
- 我的想法是，如果空字節在 application 的某個階段被移除，我可能會**覆蓋** `victim’s` 的 email 地址的註冊


```
victim%00@domain.com
```

請求通過了，但奇怪的是，當它反映我的註冊 email 時，顯示如下:  
```
victimL@domain.com
```

由於某種未知的原因，server 將 `%00` 替換為 `L`  
- 我覺得這很奇怪，所以我嘗試註冊以下的電子郵件，看看是否能重現它，以及如果有一個以上的空字節會發生什麼？

```
victim%00%00%00@domain.com
```

結果是:  
```
victimIdL@domain.com
```

似乎是隨機數據被換成了空字節
- 所以我試圖盡可能多地發送
- POST body 的最大字符數之外，完全沒有限制。我發送了一個巨大的 request，大約 10 秒鐘才得到 response

我注視著 response
- 看到了看起來是人類可讀的 data 和大量的 memory
- 我又發了一次，彈出了類似但不同的 data

在這一點上，我把我的筆記本電腦轉向每個人
- 向他們展示我正在做的事情。在每次重試 request 後，大家都嚇壞了
- 因為新的東西不斷從 server memory 中冒出來
- 我們看到了 RSA private keys,  internal HTTP requests, users, plaintext usernames and passwords，以及大量的秘密

我們回到酒店，以便我們能夠正確地利用這個問題並寫出報告。

------------------

## 發生了什麼事？
Originally we had no idea how to even guess what was going on since the issue was so strange. We all agreed it was some sort of memory corruption/buffer overflow, but it seemed so weird since we were using multiple null bytes.


最初，我們甚至不知道如何猜測發生了什麼，因為這個問題太奇怪了
- 我們都認為這是某種 memory corruption/buffer overflow (記憶體損壞/緩衝區溢出
- 但由於我們使用了多個空字節，所以看起來非常奇怪

事實證明
- 這與 Sergey Belov 在 Tweet 中的描述完全一致
- 有一個前端 application 正在將 data 傳遞給底層 C application 上的一個不安全的 function


C application 期望從前端 application (registration form) 得到兩樣東西
- String
- String length


如果你發送字符串 `abc%00`，前端 app 會認為該信息如下
- 字符串：`abc%00`
- 字符串長度：`4`


如果只是由前端 application 進行評估，這完全沒有問題
- 但在前端 application 和底層 C application 之間的傳遞過程中，空字節被刪除了
- 被發送的新 data 如下:
  - 字符串：`abc`
  - 字符串長度：`4`

如果你熟悉 C 語言，這可能是你需要知道的全部
- 但基本上每個新的空字節都增加了字符串的長度，但實際上並沒有佔用字符串的值
- 這使 `attacker` 可以創建巨大的空字符串槽，並將其填入 server memory
- 因為 server 在將字符串值返回給前端 application 之前，只是簡單地將字節數讀入

![](https://samcurry.net/wp-content/uploads/2019/11/Untitled-Diagram.png)  

概述看起來像這樣，這使得攻擊者可以簡單地一次又一次地重新提交這個請求，並一次收到數兆字節的 data


![](https://samcurry.net/wp-content/uploads/2019/12/chart_123.png)  

一個發送 data 和接收 data 的例子
- 有大量的內存，**所以接下來證明影響的過程是拉出大量的 data 並通過它來尋找秘密**
- 請注意，我們有權限這樣做，並且不建議未經許可就這樣做
- 我們寫了一個可以自動收集 data 的 script，並能夠提取大量的 data，顯示了一個令人難以置信的 `click-to-showcase proof of concept`，並匆忙提交了報告

------------------------

## Timeline
- 2019-07-30 01:30 – Reported
- 2019-07-30 02:47 – Initial response
- 2019-08-11 00:24 – Bounty paid
- 2019-08-19 19:05 – Resolved
